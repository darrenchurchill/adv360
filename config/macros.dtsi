// Macro Definitions
// https://zmk.dev/docs/behaviors/macros
// https://zmk.dev/docs/config/behaviors#macro


// NOTE:
// Macros that send a sequence of keycodes to the connected host are recommended
// to use wait & tap time of at least 30ms to avoid keypresses being processed
// out of order.
// https://zmk.dev/docs/behaviors/macros#keycode-sequences
#define MACRO_HOST_SEQUENCE_DELAY 30

// no_lshft is my workaround for a current issue with ZMK:
// Rolled keypresses from a shifted key to a non-shifted key do not release the
// shift modifier before the non-shifted key is pressed, causing the host OS to
// register the non-shifted key as a shifted key.
// A related issue was addressed here, but doesn't fix my particular issue:
// https://github.com/zmkfirmware/zmk/pull/1828
no_lshft: no_lshft {
  compatible = "zmk,behavior-macro-one-param";
  label = "no_lshft";
  #binding-cells = <1>;
  bindings
    = <&macro_release &kp LSHFT>
    , <&macro_param_1to1>, <&macro_tap &kp MACRO_PLACEHOLDER>;
};

m_db_minus: m_db_minus {
  compatible = "zmk,behavior-macro";
  label = "m_db_minus";
  #binding-cells = <0>;
  wait-ms = <MACRO_HOST_SEQUENCE_DELAY>;
  tap-ms = <MACRO_HOST_SEQUENCE_DELAY>;
  bindings = <&kp MINUS>, <&kp MINUS>;
};
m_db_underscore: m_db_underscore {
  compatible = "zmk,behavior-macro";
  label = "m_db_underscore";
  #binding-cells = <0>;
  wait-ms = <MACRO_HOST_SEQUENCE_DELAY>;
  tap-ms = <MACRO_HOST_SEQUENCE_DELAY>;
  bindings = <&kp UNDERSCORE>, <&kp UNDERSCORE>;
};
